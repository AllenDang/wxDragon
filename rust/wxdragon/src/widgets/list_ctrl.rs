use crate::base::{Point, Size, DEFAULT_POSITION, DEFAULT_SIZE, ID_ANY};
use crate::event::{Event, EventType, WxEvtHandler};
use crate::id::Id;
use crate::window::{Window, WxWidget};
use std::default::Default;
use std::ffi::CString;
use std::marker::PhantomData;
use std::os::raw::{c_int, c_long};
use wxdragon_sys as ffi;

// Constants for wxListCtrl styles (prefixed with LC_)
// These should correspond to WXD_LC_* constants generated by const_extractor
pub const LC_LIST: i64 = ffi::WXD_LC_LIST;
pub const LC_REPORT: i64 = ffi::WXD_LC_REPORT;
pub const LC_ICON: i64 = ffi::WXD_LC_ICON;
pub const LC_SMALL_ICON: i64 = ffi::WXD_LC_SMALL_ICON;
pub const LC_ALIGN_TOP: i64 = ffi::WXD_LC_ALIGN_TOP;
pub const LC_ALIGN_LEFT: i64 = ffi::WXD_LC_ALIGN_LEFT;
pub const LC_AUTOARRANGE: i64 = ffi::WXD_LC_AUTOARRANGE;
pub const LC_EDIT_LABELS: i64 = ffi::WXD_LC_EDIT_LABELS;
pub const LC_NO_HEADER: i64 = ffi::WXD_LC_NO_HEADER;
pub const LC_SINGLE_SEL: i64 = ffi::WXD_LC_SINGLE_SEL;
pub const LC_SORT_ASCENDING: i64 = ffi::WXD_LC_SORT_ASCENDING;
pub const LC_SORT_DESCENDING: i64 = ffi::WXD_LC_SORT_DESCENDING;
pub const LC_HRULES: i64 = ffi::WXD_LC_HRULES;
pub const LC_VRULES: i64 = ffi::WXD_LC_VRULES;

// Column formats
pub const LIST_FORMAT_LEFT: i32 = ffi::WXD_LIST_FORMAT_LEFT as i32;
pub const LIST_FORMAT_RIGHT: i32 = ffi::WXD_LIST_FORMAT_RIGHT as i32;
pub const LIST_FORMAT_CENTRE: i32 = ffi::WXD_LIST_FORMAT_CENTRE as i32;

// Item states
pub const LIST_STATE_SELECTED: i64 = ffi::WXD_LIST_STATE_SELECTED;
pub const LIST_STATE_FOCUSED: i64 = ffi::WXD_LIST_STATE_FOCUSED;
pub const LIST_STATE_DISABLED: i64 = ffi::WXD_LIST_STATE_DISABLED;
pub const LIST_STATE_DROPHILITED: i64 = ffi::WXD_LIST_STATE_DROPHILITED;

// GetNextItem geometry flags
pub const LIST_NEXT_ALL: i32 = ffi::WXD_LIST_NEXT_ALL as i32;
pub const LIST_NEXT_ABOVE: i32 = ffi::WXD_LIST_NEXT_ABOVE as i32;
pub const LIST_NEXT_BELOW: i32 = ffi::WXD_LIST_NEXT_BELOW as i32;
pub const LIST_NEXT_LEFT: i32 = ffi::WXD_LIST_NEXT_LEFT as i32;
pub const LIST_NEXT_RIGHT: i32 = ffi::WXD_LIST_NEXT_RIGHT as i32;

#[derive(Clone)]
pub struct ListCtrl {
    ptr: *mut ffi::wxd_ListCtrl_t,
    window: Window,
}

impl ListCtrl {
    pub fn builder(parent: &impl WxWidget) -> ListCtrlBuilder<Window> {
        let mut builder = ListCtrlBuilder::<Window>::default();
        builder.parent_ptr = parent.handle_ptr();
        builder
    }

    /// Inserts a column at the specified position.
    pub fn insert_column(&self, col: i64, heading: &str, format: i32, width: i32) -> i32 {
        let c_heading = CString::new(heading).unwrap();
        unsafe {
            ffi::wxd_ListCtrl_InsertColumn(
                self.ptr,
                col as c_long,
                c_heading.as_ptr(),
                format,
                width,
            )
        }
    }

    /// Sets the width of the specified column.
    pub fn set_column_width(&self, col: i64, width: i32) -> bool {
        unsafe { ffi::wxd_ListCtrl_SetColumnWidth(self.ptr, col as c_long, width) }
    }

    /// Gets the width of the specified column.
    pub fn get_column_width(&self, col: i64) -> i32 {
        unsafe { ffi::wxd_ListCtrl_GetColumnWidth(self.ptr, col as c_long) }
    }

    pub fn get_column_count(&self) -> i32 {
        unsafe { ffi::wxd_ListCtrl_GetColumnCount(self.ptr) }
    }

    /// Inserts a simple item (label only) at the specified index.
    pub fn insert_item(&self, index: i64, label: &str) -> i32 {
        let c_label = CString::new(label).unwrap();
        unsafe { ffi::wxd_ListCtrl_InsertItem_Simple(self.ptr, index as c_long, c_label.as_ptr()) }
    }

    /// Sets the text of an item (label in column 0).
    pub fn set_item_text(&self, index: i64, text: &str) {
        let c_text = CString::new(text).unwrap_or_default();
        unsafe { ffi::wxd_ListCtrl_SetItemText(self.ptr, index as c_long, c_text.as_ptr()) }
    }

    pub fn get_item_text(&self, index: i64, col: i32) -> String {
        unsafe {
            let needed_len = ffi::wxd_ListCtrl_GetItemText(
                self.ptr,
                index as c_long,
                col,
                std::ptr::null_mut(),
                0,
            );
            if needed_len <= 0 {
                return String::new();
            }
            let mut buffer: Vec<u8> = Vec::with_capacity(needed_len as usize);
            let actual_len = ffi::wxd_ListCtrl_GetItemText(
                self.ptr,
                index as c_long,
                col,
                buffer.as_mut_ptr() as *mut i8,
                needed_len as i32,
            );
            if actual_len <= 0 {
                return String::new();
            }
            buffer.set_len(actual_len as usize);
            String::from_utf8_lossy(&buffer).into_owned()
        }
    }

    pub fn get_item_count(&self) -> i32 {
        unsafe { ffi::wxd_ListCtrl_GetItemCount(self.ptr) }
    }

    /// Sets the state of an item.
    pub fn set_item_state(&self, item: i64, state: i64, state_mask: i64) -> bool {
        unsafe {
            ffi::wxd_ListCtrl_SetItemState(
                self.ptr,
                item as c_long,
                state as c_long,
                state_mask as c_long,
            )
        }
    }

    /// Gets the state of an item.
    pub fn get_item_state(&self, item: i64, state_mask: i64) -> i32 {
        unsafe { ffi::wxd_ListCtrl_GetItemState(self.ptr, item as c_long, state_mask as c_long) }
    }

    /// Gets the next item based on geometry and state.
    pub fn get_next_item(&self, item: i64, geometry: i32, state: i32) -> i32 {
        unsafe { ffi::wxd_ListCtrl_GetNextItem(self.ptr, item as c_long, geometry, state) }
    }

    pub fn get_first_selected_item(&self) -> i32 {
        self.get_next_item(-1, LIST_NEXT_ALL as c_int, LIST_STATE_SELECTED as c_int)
    }

    /// Deletes the specified item.
    pub fn delete_item(&self, item: i64) -> bool {
        unsafe { ffi::wxd_ListCtrl_DeleteItem(self.ptr, item as c_long) }
    }

    pub fn delete_all_items(&self) -> bool {
        unsafe { ffi::wxd_ListCtrl_DeleteAllItems(self.ptr) }
    }

    pub fn clear_all(&self) -> bool {
        unsafe { ffi::wxd_ListCtrl_ClearAll(self.ptr) }
    }

    pub fn get_selected_item_count(&self) -> i32 {
        unsafe { ffi::wxd_ListCtrl_GetSelectedItemCount(self.ptr) }
    }

    /// Ensures that the specified item is visible.
    pub fn ensure_visible(&self, item: i64) -> bool {
        unsafe { ffi::wxd_ListCtrl_EnsureVisible(self.ptr, item as c_long) }
    }

    /// Determines which item, if any, is at the specified point.
    /// Returns a tuple (item_index, flags, subitem_index).
    pub fn hit_test(&self, point: Point) -> (i32, i32, i32) {
        let mut flags: i32 = 0;
        let mut subitem: c_long = 0;
        let item = unsafe {
            ffi::wxd_ListCtrl_HitTest(
                self.ptr,
                point.into(),
                &mut flags as *mut i32,
                &mut subitem as *mut c_long,
            )
        };
        (item, flags, subitem as i32)
    }

    /// Starts editing the label of the specified item.
    pub fn edit_label(&self, item: i64) {
        unsafe { ffi::wxd_ListCtrl_EditLabel(self.ptr, item as c_long) }
    }

    pub fn bind<F>(&self, event_type: EventType, callback: F)
    where
        F: FnMut(Event) + 'static,
    {
        self.window.bind(event_type, callback)
    }
}

impl WxWidget for ListCtrl {
    fn handle_ptr(&self) -> *mut ffi::wxd_Window_t {
        self.window.handle_ptr()
    }
}

impl Drop for ListCtrl {
    fn drop(&mut self) {
        // Ownership is managed by the parent window/app in wxWidgets typically
        // No explicit Destroy call needed for ListCtrl if it's a child of a window
        // that gets destroyed, unless specifically detached or created as a top-level like window.
        // For now, assume it's cleaned up by parent like other controls.
    }
}

pub struct ListCtrlBuilder<P: WxWidget + Clone> {
    parent_ptr: *mut ffi::wxd_Window_t,
    id: Id,
    pos: Point,
    size: Size,
    style: i64,
    _phantom: PhantomData<P>,
}

impl<P: WxWidget + Clone> Default for ListCtrlBuilder<P> {
    fn default() -> Self {
        Self {
            parent_ptr: std::ptr::null_mut(),
            id: ID_ANY,
            pos: DEFAULT_POSITION,
            size: DEFAULT_SIZE,
            style: LC_REPORT,
            _phantom: PhantomData,
        }
    }
}

impl<P: WxWidget + Clone> ListCtrlBuilder<P> {
    pub fn with_id(mut self, id: Id) -> Self {
        self.id = id;
        self
    }

    pub fn with_pos(mut self, pos: Point) -> Self {
        self.pos = pos;
        self
    }

    pub fn with_size(mut self, size: Size) -> Self {
        self.size = size;
        self
    }

    pub fn with_style(mut self, style: i64) -> Self {
        self.style = style;
        self
    }

    pub fn build(self) -> ListCtrl {
        assert!(!self.parent_ptr.is_null(), "ListCtrl requires a parent");
        let ptr = unsafe {
            ffi::wxd_ListCtrl_Create(
                self.parent_ptr,
                self.id,
                self.pos.into(),
                self.size.into(),
                self.style as ffi::wxd_Style_t,
            )
        };
        if ptr.is_null() {
            panic!("Failed to create ListCtrl: FFI returned null pointer.");
        } else {
            unsafe {
                ListCtrl {
                    ptr,
                    window: Window::from_ptr(ptr as *mut ffi::wxd_Window_t),
                }
            }
        }
    }
}

// Add specific ListEventData if needed, or ensure current Event can handle it.
// For example, if ListEventData needs methods like get_item_index(), get_column(), get_label().
// For now, assuming base Event with get_id() is used, and specific data access
// will be added to the generic Event<T> system or through specialized event types.
